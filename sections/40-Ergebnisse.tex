% !TEX root = ../TUCthesis.tex
%************************************************
\chapter{Ergebnisse}\label{ch:ergebnisse}
%************************************************
\section{Validierung des Gesamtkonzeptes}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Testfälle und Beziehung zu Problemen aus Kapitel 4
%
% Eine oftmals hilfreiche Form, die Inhalte dieses Kapitels zu veranschaulichen, ist eine Tabelle,
% welche die Requirements / die Probleme aus Kapitel 4 und die Tests / Ergebnisse aus Kapitel
% 5 zuordnet. Aus dieser Tabelle ist dann ersichtlich, welche Teile abgedeckt, getestet, nicht
% testbar, erwartungsgemäß, abweichend etc. sind.
%
%
% Gesetz der Großen Zahlen, Varianz, Standardabweichung
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{table}[t]
    \caption{Erforderliche Testfälle} 
    \myfloatalign
    \begin{tabularx}{\textwidth}{lX}
        \toprule 
        \tableheadline{Anforderung} & \tableheadline{Testfall} \\ 
        \midrule 
        Kartensuche: Schlüsselwort-Fähigkeit & Suche alle Karten mit einer bestimmten Fähigkeit \\
        Kartensuche: Textsuche & Suche nach einer Zeichenkette die in einem Kartennamen vorkommt\\
        Kartensuche: Verknüpfungen & Suche anhand verschiedener Karten-Attribute \\
        Turnier: Matchup Analyse & Berechne das Matchup eines Deck-Typen \\
        \bottomrule 
    \end{tabularx}
    \label{tab:req.tests}
\end{table}
In \autoref{tab:req.tests} befindet sich eine Auflistung der Probleme die in \autoref{ch:analyse} beschrieben wurden und welche Testfälle erforderlich sich, um die Anforderung zu überprüfen.

Jeder Test wurde 1000mal sowohl auf Neo4j als auch auf MySQL ausgeführt, um den Einfluss von Messfehlern zu reduzieren \emph{(Gesetz der Großen Zahlen)}. Bei jedem Test wurde die Ausführungszeit in Millisekunden (ms) und der Speicherverbrauch in MByte gemessen. Um sicherzugehen, dass Caching oder Systemprozesse die Ergebnisse nicht beeinflussen, wurden die 10 längsten und kürzesten Zeiten verworfen. Die übriggebliebenen Werte wurden gemittelt und die Standardabweichung wurde berechnet, um zu schauen wie groß die Fehlergrenze ist. 

Um zu erfahren wie gut die beiden Datenbanken skalieren, wurden außerdem die Testfälle stückweise auf größeren Datensätzen ausgeführt. Diese Datensätze wurden zufällig generiert und basieren nicht auf echten Daten. Als Staffelung für die Tests wurden \emph{100.000, 250.000, 500.000 und 1.000.000} Karten/Turniere gewählt.

\section{Beschreibung und Motivation der Testfälle}
%% Tests in normaler Sprache:
%% zB: Testfall X: Suche nach allen Karte die aus Set Y sind und Kriterium Z erfüllen
%%  -> guter test, da viele Verknpüfungen

\subsection{Testfall 1: Schlüsselwort-Fähigkeit}
Eine einfache Suche, um die ersten 300 Karten mit dem Schlüsselwort-Fähigkeit \emph{Flying} zu erhalten. Wie in \autoref{fig:uml:schema} zu sehen ist, werden die Fähigkeiten in MySQL in einer eigenen Tabelle gespeichert. In Neo4j hingegen können diese als Attribut von \emph{Card} hinterlegt werden \emph{(siehe \autoref{fig:graph:schema})}, da Neo4j den Datentyp \emph{Array} unterstützt. Mit diesem Test lässt sich also vergleichen wie gut sich Arrays im Vergleich zu joins beim durchsuchen eignen.
    
\subsection{Testfall 2: Textsuche}
Eine einfache Suche nach den Karten, die den Namen \emph{Forest} enthalten und die entweder von \emph{Aleksi Briclot} oder \emph{John Avon} gezeichnet wurden. Da Karten anhand ihres Namens identifiziert werden, ist es sinnvoll zu testen wie gut sich eine Textsuche in den beiden Datenbanksystemen funktioniert.

\subsection{Testfall 3: Verknüpfungen}
Eine komplexe Suche nach Karten, welche bestimmte Kriterien erfüllen \emph{(siehe \ref{listing:complex.sql})}. Es wird nach Karten gesucht, die folgende Eigenschaften erfüllen:
\begin{itemize}
    \item in einem Set nach dem \emph{01.01.2001} erschienen
    \item als Seltenheit \emph{RARE} besitzen
    \item in \emph{deutscher} Sprache erschienen
    \item als Farbe \emph{Blau} haben
    \item vom Typ \emph{Kreatur} sind
    \item die Fähigkeit \emph{Flying} besitzen
    \item umgewandelte Manakosten von \emph{maximal 5} haben
 \end{itemize} 

\subsection{Testfall 4: Matchup Analyse}
Berechnung des Matchup für den Deck-Typ \emph{Bant}. Es werden alle Matches analysiert an denen ein Deck vom Typ \emph{Bant} beteiligt war und überprüft ob das Deck gewonnen oder verloren hat. Die Ergebnisse werden dann anhand der gegnerischen Deck-Typen gruppiert und geordnet. Insgesamt gibt es im Standard-Testfall 1000 Turniere, die jeweils zwischen 2 und 6 Matches enthalten.  


\section{Übersicht und Bewertung der erzielten Ergebnisse}
%%
%% Graphen! + Berwertung (erwaret/unwartet, weil | DB X besser geeignet weil)
%%
\subsection{Laufzeit}
Die gemessenen Laufzeiten samt ihrer Standardabweichung sind in \autoref{fig:plot.runtime} als Fehlerbalkendiagramm dargestellt.
Wie zu erwarten war Neo4j in Testfall 4 schneller als die MySQL-Abfrage mit JOINS. Überraschenderweise war Neo4j auch in Testfall 2 etwas schneller als MySQL, obwohl aufgrund der langjährigen Optimierungen der Textsuche in MySQL zu erwarten war, dass dieser schneller sei.
Der Grund dafür, dass Neo4j in den Testfällen 1 und 3 langsamer ist als MySQL liegt vermutlich daran, dass als Datentyp Arrays für \emph{color}, \emph{abilities} und \emph{types} benutzt wurde. Anscheinend ist in Neo4j die Suche innerhalb eines Arrays langsamer als die Suche mit einem JOIN in MySQL.

\begin{figure}[t]
    \myfloatalign
    \begin{tikzpicture} 
        \begin{axis}[
            width=0.75*\linewidth, % Scale the plot to \linewidth
            grid=major, % Display a grid
            grid style={dashed,gray!30}, % Set the style
            xlabel=Testfälle, % Set the labels
            ylabel=Laufzeit,
            use units,
            y unit=ms,
            %legend style={at={(0.5,-0.2)},anchor=north}, % Put the legend below the plot             
            ybar,
            symbolic x coords={Test 1, Test 2, Test 3, Test 4},
            xtick=data,
            %nodes near coords,
            %nodes near coords align={vertical}
        ]
            \addplot+[error bars/.cd,y dir=both,y explicit]
            table[x=Test,y=Neo4j,y error=Neo4j error,col sep=comma]{evaluation-results/testcases-runtime.n-1000.csv};
            
            \addplot+[error bars/.cd,y dir=both,y explicit]
            table[x=Test,y=MySQL,y error=MySQL error,col sep=comma]{evaluation-results/testcases-runtime.n-1000.csv};
            
            \legend{Neo4j, MySQL}
        \end{axis}
    \end{tikzpicture}
    \caption{Ausführungszeit der einzelnen Testfälle}
    \label{fig:plot.runtime}
\end{figure}

%\begin{table}[t]
%    \caption{Gemessene Laufzeiten der Testfälle} 
%    \myfloatalign
%    \csvreader[tabular=lrrrr,table head=\toprule Test & Neo4j (ms) & Neo4j STD (ms) & MySQL (ms) & MySQL STD (ms) \\\midrule,late after last line=\\\bottomrule]%
%    {evaluation-results/testcases-runtime.n-1000.csv}{Test=\test,Neo4j=\neo,Neo4j error=\neostd,MySQL=\mysql,MySQL error=\mysqlstd}%
%    {\test & \neo & \neostd & \mysql & \mysqlstd}%
%    \label{tab:runtime}
%\end{table}

\subsection{Skalierbarkeit}
Wie in \autoref{fig:plot.scaling.testcase1} zu sehen ist, skalieren sowohl Neo4j als auch MySQL gut, aber auch hier zeigt sich, dass Neo4j in allen gemessenen Größen langsamer ist. Die Vermutung, dass die Suche in Arrays langsamer ist als mit JOINS bestätigt sich in Testfall 3. Wie in  \autoref{fig:plot.scaling.testcase3} zu sehen ist, hat die Laufzeit bei Neo4j ein lineares Wachstum, wohingegen sie bei MySQL relativ konstant bleibt: bei doppelter Menge an Karten, verdoppelt \emph{(ungefähr)} sich die Laufzeit in Neo4j. Es bietet sich an zu überprüfen, ob mit einem anderen Schema, welches auf Arrays verzichtet, Neo4j eine bessere Laufzeit und Skalierbarkeit hat.

In Testfall 2 bestätigt sich, dass MySQL bei der Textsuche optimierter ist als Neo4j, auch wenn Neo4j mit dem normalen Datensatz ein wenig schneller ist. In \autoref{fig:plot.scaling.testcase2} ist zu sehen, dass sich auch hier mit Verdopplung der Karten die Laufzeit der Neo4j-Abfrage um den Faktor 1.5 - 2 steigt, wohingegen die Laufzeit bei MySQL nur um 5\% - 10\% pro gemessenem Punkt steigt. MySQL ist also wie erwartet besser für Textsuchen geeignet als Neo4j.

In \autoref{fig:plot.scaling.testcase4} zeigt sich, dass die Laufzeit der MySQL-Abfrage für Testfall 4 ein exponentielles Wachstum hat. Bei der Neo4j Abfrage hingegen steigt die Laufzeit linear, das heißt für Turnier/Matchup-Analysen ist Neo4j besser geeignet als MySQL.

\begin{figure}[t]
    \myfloatalign
    \begin{tikzpicture} 
    \begin{axis}[
        width=0.70*\linewidth, % Scale the plot to \linewidth
        grid=major, % Display a grid
        grid style={dashed,gray!30}, % Set the style
        xlabel=\# Karten, % Set the labels
        ylabel=Laufzeit,
        use units,
        y unit=ms,
        legend pos=north west,
    ]
    \addplot+[color=blue, mark=*,error bars/.cd,y dir=both,y explicit]
    table[x=Size,y=Neo4j,y error=Neo4j error,col sep=comma]{evaluation-results/testcases-runtime.n-1000.testcase1.csv};
    
    \addplot+[color=red, mark=square,error bars/.cd,y dir=both,y explicit]
    table[x=Size,y=MySQL,y error=MySQL error,col sep=comma]{evaluation-results/testcases-runtime.n-1000.testcase1.csv};
    
    \legend{Neo4j, MySQL}
    \end{axis}
    \end{tikzpicture}
    \caption{Skalierung Testfall 1}
    \label{fig:plot.scaling.testcase1}
\end{figure}

\begin{figure}[H]
    \myfloatalign
    \begin{tikzpicture} 
    \begin{axis}[
        width=0.70*\linewidth, % Scale the plot to \linewidth
        grid=major, % Display a grid
        grid style={dashed,gray!30}, % Set the style
        xlabel=\# Karten, % Set the labels
        ylabel=Laufzeit,
        use units,
        y unit=ms,
        legend pos=north west,
    ]
    \addplot+[color=blue, mark=*,error bars/.cd,y dir=both,y explicit]
    table[x=Size,y=Neo4j,y error=Neo4j error,col sep=comma]{evaluation-results/testcases-runtime.n-1000.testcase2.csv};
    
    \addplot+[color=red, mark=square,error bars/.cd,y dir=both,y explicit]
    table[x=Size,y=MySQL,y error=MySQL error,col sep=comma]{evaluation-results/testcases-runtime.n-1000.testcase2.csv};
    
    \legend{Neo4j, MySQL}
    \end{axis}
    \end{tikzpicture}
    \caption{Skalierung Testfall 2}
    \label{fig:plot.scaling.testcase2}
\end{figure}

\begin{figure}[t]
    \myfloatalign
    \begin{tikzpicture} 
    \begin{axis}[
        width=0.70*\linewidth, % Scale the plot to \linewidth
        grid=major, % Display a grid
        grid style={dashed,gray!30}, % Set the style
        xlabel=\# Karten, % Set the labels
        ylabel=Laufzeit,
        use units,
        y unit=ms,
        legend pos=north west,
    ]
    \addplot+[color=blue, mark=*,error bars/.cd,y dir=both,y explicit]
    table[x=Size,y=Neo4j,y error=Neo4j error,col sep=comma]{evaluation-results/testcases-runtime.n-1000.testcase3.csv};
    
    \addplot+[color=red, mark=square,error bars/.cd,y dir=both,y explicit]
    table[x=Size,y=MySQL,y error=MySQL error,col sep=comma]{evaluation-results/testcases-runtime.n-1000.testcase3.csv};
    
    \legend{Neo4j, MySQL}
    \end{axis}
    \end{tikzpicture}
    \caption{Skalierung Testfall 3}
    \label{fig:plot.scaling.testcase3}
\end{figure}

\begin{figure}[H]
    \myfloatalign
    \begin{tikzpicture} 
    \begin{axis}[
        width=0.70*\linewidth, % Scale the plot to \linewidth
        grid=major, % Display a grid
        grid style={dashed,gray!30}, % Set the style
        xlabel=\# Turniere, % Set the labels
        ylabel=Laufzeit,
        use units,
        y unit=ms,
        legend pos=north west,
    ]
    \addplot+[color=blue, mark=*,error bars/.cd,y dir=both,y explicit]
    table[x=Size,y=Neo4j,y error=Neo4j error,col sep=comma]{evaluation-results/testcases-runtime.n-1000.testcase4.csv};
    
    \addplot+[color=red, mark=square,error bars/.cd,y dir=both,y explicit]
    table[x=Size,y=MySQL,y error=MySQL error,col sep=comma]{evaluation-results/testcases-runtime.n-1000.testcase4.csv};
    
    \legend{Neo4j, MySQL}
    \end{axis}
    \end{tikzpicture}
    \caption{Skalierung Testfall 4}
    \label{fig:plot.scaling.testcase4}
\end{figure}


\subsection{Speicherverbrauch}
Der gemessene Speicherverbrauch in MByte unterscheidet sich zwischen MySQL und Neo4j faktisch nicht, das heißt er beträgt weniger als 0.1\%. Des Weiteren bleibt dieser auch bei der Skalierung der Datenbank relativ konstant mit $\pm1$MByte Abweichung. Aus diesem Grund wird hier nicht weiter auf den Speicherverbrauch eingegangen.